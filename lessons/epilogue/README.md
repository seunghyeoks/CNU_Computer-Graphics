# 23. Epilogue

## :tada: 수고 많으셨습니다! :tada:

여러분은 이번 학기동안 이 Repository를 통해 WebGL API의 기본적인 원리와 사용 방법, 셰이더를 활용한 기본적인 3차원 그래픽스의 구현 방법에 대해 모두 배우셨습니다. 마지막의 Shadow Mapping은 꽤 어려운 내용이었고, 아마 일반적으로 한학기동안 배우는 그래픽스 강의에서는 잘 다루지 않는 내용일지도 모르겠는데, 여러분은 다 배우셨으니 스스로 자랑스럽게 생각하셔도 되겠습니다.

제가 강의를 시작하면서 이 수업이 WebGL(또는 OpenGL) 프로그래밍 보다는 이론을 이해하는 것이 더 중요하다고 말씀드렸고, 지금도 그렇게 생각합니다. 하지만 실제로 프로그램을 작성해 봄으로써 이미 배운 내용을 더 잘 이해할 수도 있고, 그래픽스에 대한 흥미도 높아질 수 있기 때문에 이렇게 Repository를 (힘들게) 준비해 둔 것입니다. 제가 기대한 효과가 있었으면 좋겠습니다. 

마지막으로 우리가 지금까지 배운 내용을 한번 복습해 보고, 향후 여러분들이 흥미가 있으시다면 더 보면 좋을 자료들을 소개해 드리고 마치도록 하겠습니다.

---

## Table of Contents

[Table of Contents](../README.md) 페이지에 WebGL 실습 관련한 모든 내용에 링크를 걸어 두었습니다. 나중에 다시 찾아보실때도 편리하실 겁니다. 지금은 복습 겸 제목만 보면서 어떤 내용들을 배웠는지 같이 한번 리마인드 해보도록 합시다.

> 지금 저를 따라서 복기를 해보면, 일주일 정도는 내용이 쭉 기억이 나실겁니다. 그리고 다음 주에 한번 더 보면 한달 정도 기억이 나실거고, 한달뒤에 한번 더 보시면 반년 정도 기억이 나실겁니다. 이렇게 8번 정도 복습하면 장기 기억으로 변경되어 오래 기억에 남는다고 합니다. 그렇게 되면 면접에서 관련 질문을 받았다던가, 나중에 다시 흥미가 생겨서 개발을 할 때에 깨끗한 기억으로 처음부터 다시 공부해야 하는 불상사를 막을 수 있습니다.

---

1~9까지는 기본적인 WebGL의 동작 방식에 대해 배웠습니다. GPU에 데이터를 전달하고 셰이더 프로그램을 실행하여 화면을 그리는 과정에 대해 잘 기억해 두시기 바랍니다.

- [01. Vertex Buffer]
    * GPU에 버퍼를 생성(`createBuffer`)하고 데이터를 집어넣는 법(bind 후에 `bufferData`)을 배웠습니다.
    * State machine으로 설계된 API에서 바인딩의 개념도 알아봤습니다. 목적지를 인자로 넘기는 것이 아니고, 바인드 포인트(ex, `gl.ARRAY_BUFFER`)에 객체를 바인딩해 놓은 뒤에, 바인드 포인트와 관련한 API를 호출하면 그 객체에 적용되는 식이었습니다. 
- [02. Shader Attributes]
    * 각 정점의 위치,법선,텍스처 좌표 등을 입력하기 위한 Attribute에 대해 배웠습니다.
    * 정점 버퍼를 바인딩하고, 데이터를 끊어서 읽는법(stride, offset, type)을 각 attribute location에 대해 알려줘야 했습니다. GPU에는 바이트의 덩어리가 넘겨졌을 뿐, 해석하는 방법은 모르기 때문입니다.
- [03. Draw from Index]
    * 메모리 소요를 줄이기 위해 인덱스 기반으로 그리는 법도 알아봤습니다. 인덱스 버퍼를 별도로 만들고 바인딩해야 합니다.
    * 그릴때는 `gl.drawElements()`를 사용해야 합니다.
- [04. Shader Uniform] & [05. Shader Uniform (Interactive)]
    * Uniform은 attribute처럼 각 정점별 데이터가 아니고, 한 물체에 대해 공통적으로 사용되는 값입니다. 대표적으로 MVP 행렬이 uniform으로 입력됩니다.
    * Uniform을 갱신하여 장면을 계속 새로 그림으로써 인터랙티브한 어플리케이션을 만들 수 있습니다.
- [06. Drawing Multiple Objects (Part 1)] & [06. Drawing Multiple Objects (Part 2)]
    * VAO를 통해 물체를 그릴때 사용할 버퍼와 데이터 읽는 방법을 손쉽게 저장해 둘 수 있습니다.
    * 물체를 그리기 위해서느 VAO와 셰이더를 바인딩한 뒤, 셰이더에 필요한 uniform을 설정한 후 드로우콜을 호출합니다.
- [07. Buffer Abstraction] & [08. Vertex Array Abstraction] & [09. Shader and Renderer Abstraction]
    * 클래스를 구현하고, Bind/Unbind 인터페이스를 구현해 두면 코드가 간결해집니다.

---
10~13까지는 Model, View, Projection 행렬과 그 적용 방식에 대해 배웠습니다.

- [10. Using Matrix]
    * glMatrix라는 라이브러리를 사용하는 방법에 대해 간단히 알아봤습니다. 참조 문서에 사용을 위한 모든 정보가 들있습니다.
    * 뷰 행렬, 투영 행렬을 만들어주는 기능, 행렬 및 벡터 연산을 수행하는 기능을 적극 사용합니다.
- [11. Input Handling (Color Change)] & [11. Input Handling (Camera Control)]
    * 키보드 & 마우스 입력으로 카메라를 움직여 봤습니다. 입력이 발생할때마다 뷰 행렬을 업데이트하여 uniform으로 셰이더에 전달하고 화면을 다시 그렸었죠.
- [12. Model Matrix and Load OBJ]
    * 간단한 육면체 OBJ 파일을 열어보고, 라이브러리를 사용해 로딩해 봤습니다.
    * 모델 행렬을 적용해 회전까지 시켜서 MVP 행렬을 모두 적용해 봤습니다. 셰이더 내부에 a_position에 모델, 뷰, 투영 행렬을 곱해줬습니다. (곱하는 순서를 잘 기억해 두셔야겠죠?)
- [13. Model Abstraction]
    * 모델을 로딩한후 VAO를 준비하는 기능, `Draw()` 인터페이스를 통해 셰이더를 입력하면 그리는 기능까지를 모델 클래스에 구현하면 편리하게 사용 가능합니다.

---
14~18까지는 이미지 텍스처링과 라이팅 기법에 대해 배웠습니다.

- [14. Texture]
    * 텍스처 객체를 GPU에 생성하고, 이미지를 JS에서 비동기 로딩한 뒤 `gl.texImage2D()`를 사용해 데이터를 집어넣었습니다.
    * 텍스처는 "텍스처 유닛"(ex, `gl.TEXTURE0`)에 바인딩하여 사용한다는 사실을 잘 기억해 두세요.
    * 2차원 텍스처는 셰이더 내에서 `sampler2D` 타입으로 참조되고, `texture()` 내장함수로 값을 샘플링합니다.

- [15. Ambient Term] & [16. Diffuse Term] & [17. Specular Term]
    * 조명 효과의 핵심은 내적을 통해서 각도를 계산하는 것이었습니다. Diffuse에서는 `dot(n,l)` Specular에서는 `dot(r,v)`였습니다. 
    * 모든 내적 연산은 같은 공간에서 해야 한다는 사실이 중요하고, 우리 예제에서는 모두 월드공간에서 수행했습니다. 그래서 `n`벡터를 transpose(inverse(model))과 곱해줬죠.
    * varying으로 프래그먼트 셰이더에 전달되면 길이가 바뀐다는 사실에 주의하세요. 그래서 법선벡터를 계산 전에 다시 정규화 했습니다.
    * 추가적으로 셰이더 내 구조체(ex, DirectioanlLight) uniform에 데이터를 설정하는 방식도 복기해 보세요.
- [18. Light Abstraction]
    * 상속으로 Light와 Directional Light를 구현했습니다. Specular 관련 데이터는 Material 에 넣었고 Light에 넣지 않았습니다. 이유를 복기해 보세요.

---
19~22까지는 Shadow Mapping 기법을 활용한 그림자 생성 기법을 배웠습니다.

- [19. Depth Map]
    * 프레임버퍼(FBO)의 개념을 잘 기억해 두세요. 색상+깊이+(스텐실) 데이터를 포함하며, 그리기의 대상으로 선택할 수 있습니다. 
    * 프레임버퍼에 그린 결과는 부착된 텍스처에 저장됩니다.
    * 깊이 데이터는 Z-buffering 과정에서 자동 생성되기 때문에 프래그먼트 셰이더가 비어 있었습니다.

- [20. Shadow Mapping (First Try)] & [21. Shadow Mapping (Add Bias)] & [22. Shadow Mapping (PCF)]
    * 첫 번째 패스에서 저장한 깊이맵을 활용해, 두 번째 패스에서 픽셀의 그림자 여부를 판별합니다.
    * 픽셀을 조명 공간으로 변환하여 `d`와 깊이맵의 UV 좌표(깊이맵에서 z값을 조회하는데 사용)를 얻습니다. `d > z`이면 그림자 영역입니다.
    * varying의 경우 필요하다면 perspective division을 직접 해줘야 합니다.
    * 에일리어싱 문제로 Shadow Acne가 발생합니다. Bias를 `d`에서 빼서 해결합니다.
    * 부드러운 그림자를 위해 주변 `z`값들과 비교를 통해 얼마나 그림자가 지는지 비율을 계산해 사용하는 PCF 기법을 사용할 수 있습니다. 
---
2022년에 추가된 23에서는 PBR을 설명하였습니다. 강의 내용을 잘 이해하셨다면 코드 자체는 어려운 것이 없으실 겁니다. 이론이 좀 더 어렵죠.

- [23. PBR(Physically based Rendering)]
    * PBR은 미세면 모델의 사용, 에너지 보존법칙의 준수, 물리기반 BRDF의 사용 세 가지 조건을 만족하는 렌더링 방식을 일컫는 용어입니다.
    * PBR의 기반이 되는 Reflectance Equation에 존재하는 적분 계산을 점 조명에 대해서라면 각 조명 radiance의 합으로 계산할 수 있습니다.
    * Cook-Torrance BRDF 중, Specular BRDF항은 강의 자료에 적혀있는 식들을 그대로 코드로 구현하기만 하면 사용할 수 있었습니다.
    * 점 조명과 같은 직접 조명이 아닌 경우에는 조금 더 복잡한 계산과 추가적인 데이터가 필요한데 이는 강의 자료에서 생략하였습니다.

---

## What to do next?

아래 내용의 순서는 중요도와 관련 없습니다. 여러 토픽 중에 본인이 관심이 있는 내용에 대해 살펴보시면 됩니다.

## 0. Computer vision & deep learning

컴퓨터 그래픽스는 가상의 이미지를 만들어내는 기술이고, 컴퓨터 비전은 물리적인 세계에서 수집한 이미지(실제 세계에서 찍은 사진)를 컴퓨터가 이해할 수 있도록 만들어주는 기술입니다. 컴퓨터 그래픽스와 컴퓨터 비전 기술은 그 이론과 응용에서 모두 굉장히 밀접하게 관련되어 있습니다. 컴퓨터 비전(과 딥러닝) 기술을 배운다면 양쪽에서 배운 내용이 시너지를 일으킬 수 있고, 스스로 멋진 아이디어도 떠올리실 수 있을 거라고 확신합니다.

관심이 있으시다면 컴퓨터 비전 강의도 꼭 들으시길 추천 드립니다.

## 1. Advanced Computer Graphics

이번학기에 많은 내용을 배우기는 했지만 안타깝게도 그게 끝은 아닙니다. 대신 이번학기 강의를 통해 더 발전된 알고리즘들을 배울 준비는 되신 겁니다. 여러분도 실시간 레이 트레이싱(RTX)이니, MSAA니, 비등방성 필터링이니 하는 것들을 어디에선가(대개는 게임의 그래픽 옵션에서) 한번 들어 보셨을 수도 있습니다. 컴퓨터 그래픽스 분야도 빠르게 성장하는 분야다 보니 이러한 새로운 알고리즘, 기능들이 지속적으로 개발되고 있습니다. 

기본 교재들에는 대개 이러한 내용이 들어있지 않으니, 최신 컴퓨터 그래픽스 기법에 대해 보다 깊은 이해를 하고 싶으신 경우 아래 자료들을 참고하시면 좋습니다.

- [(강추!)(Textbook) Real-time Rendering](https://www.realtimerendering.com/): 실시간 그래픽스와 관련한 최신 알고리즘들이 아주 extensive하게 소개되고 있습니다. 특정 문제들에 대해 어떤 알고리즘들이 제안되었고, 현재 근황은 어떤지 알아보실 때 유용합니다.

- [(Textbook) GPU Gems](https://developer.nvidia.com/gpugems/gpugems3/foreword): 위와 비슷하지만 좀 더 좁은 주제에 대해 다루는 것 같습니다. 프린트된 책도 있고, 온라인에서도 무료로 볼 수 있습니다. 저도 이번학기 강의 준비하면서 참고자료로 찾다 알게 되었는데 내용이 잘 정리되어 있어서 천천히 볼 생각입니다.

- [(Textbooks) 물리 기반 렌더링](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788960777620&orderClick=LAG&Kc=): PBR관련 이론과 구현을 설명한 교재입니다.

## 2. 게임 개발

> ### !! 매 방학때마다 게임 개발에 관심이 있으신 분들을 대상으로 프로젝트 진행을 도와드리고 있습니다. 관심이 있으시면 언제든지 hk.kim@cnu.ac.kr로 연락 주세요!!

게임 개발에 관심이 있으신 분이 많으실 것 같습니다. 게임 개발에 관심이 있으시다면 대개는 게임 엔진을 사용하시게 될겁니다. 게임 엔진의 기능 중, 우리가 배운 렌더링 관련 내용은 극히 일부분일 뿐입니다. 실제로 게임을 만들어 보는것에 관심이 있으신 분은 바로 Unity3D, Unreal Engine, Godot 등에 대해 공부하고 다양한 기능들을 익히시면 됩니다.

게임 개발에 이번학기에 배운 내용이 도움이 되느냐 하면 저는 확실히 된다고 말씀드릴 수 있습니다. 카메라가 어떻게 동작하는지, 셰이더와 머티리얼, 텍스처가 뭔지, 메쉬 데이터가 어떻게 이루어져 있는지 등을 알고 게임을 개발하는 것과 모르고 개발하는 것에는 큰 차이가 존재합니다. 특히 그래픽 효과를 개발할 필요가 있는경우, 렌더링에 이슈가 발견되어 해결해야 할 경우 그래픽스 이론을 모르신다면 어둠 속을 헤매게 되실겁니다.

아래는 몇 가지 추천드리는 자료들입니다. 사실 게임엔진 관련 자료는 너무나 많아서 본인 수준에 맞는 자료를 먼저 찾아 보시기를 추천 드립니다. 아래 내용들은 기본기를 익히신 후에 보시면 더 좋을만한 자료들입니다. (GameDev.tv 내용은 그냥 보셔도 됩니다.)

- [(강추!)(Youtube) "Sebastian Lague"](https://www.youtube.com/channel/UCmtyQOKKmrMVaKuRXz02jbQ): 굉장히 유용한 Unity 튜토리얼 및 개발 관련 자료들을 올려주시고 있습니다. 특히 "Create a Game" 재생목록의 내용이 좋았습니다.

- [(Website) Catlike Coding](https://catlikecoding.com/unity/tutorials/): Unity C# 및 셰이더 관련 튜토리얼들이 있습니다. 조금 어려울 수 있지만, Unity 게임 엔진에 대한 보다 확실한 이해를 하는데는 많은 도움이 될것 같습니다.

- [(Website) Shader Tutorial by Ronja](https://www.ronja-tutorials.com/): Unity의 셰이더 시스템 관련해서는 이 사이트의 자료가 가장 이해하기 쉽게 구성되어 있었습니다.

- [(Website) GameDev.tv](https://www.gamedev.tv/): 유료긴 하지만, 그에 걸맞는 수준의 강의들을 제공해 주고 있습니다. 특히 저같은 경우 Unreal Engine을 처음 접할 때 유용하게 사용했습니다.

## 3. 게임 엔진 개발

좀더 고급 프로그래밍을 배우시고 싶다면 게임 엔진 개발 내용을 한번 보시는 것을 추천 드립니다. 즉, 게임 엔진 자체를 OpenGL, WebGL, Direct3D 등의 그래픽스 API를 기반으로 만들어 보는 것입니다. 굉장히 어려운 내용일 수 있지만, 실력과 이해도는 확실히 성장하실 겁니다.

- [(Textbook) 게임 엔진 아키텍처](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791156006626&orderClick=LEa&Kc=): 저도 아직 읽는 중이라 내용을 기반으로 추천드리는 것은 아니지만, 게임 엔진의 사용법이 아닌 구조과 관련해서는 거의 유일한 책인 것 같습니다.

- [(강추!)(Youtube) The Cherno](https://www.youtube.com/channel/UCQ-W1KE9EYfdxhL6S4twUNw): EA에서 엔진 개발자로 근무했던 분이 OpenGL을 기반으로 게임 엔진 제작 시리즈를 올리고 있습니다. (저는 후원도 하고 있습니다.) 번외로 C++ 강의도 좋으니 한번 들어 보세요.

- [(강추!)(Youtube) ChiliTomatoNoodle](https://www.youtube.com/channel/UCsyHonfwHi4fLb2lkq0DEAA): 학생 분들께 추천을 드리기는 조금 그렇지만... Direct3D 11 기반으로 게임 엔진 제작에 가까운 시리즈를 올리고 있습니다. 내용은 정말 훌륭합니다.

## 4. Web 3D 그래픽스

웹에서의 3D 그래픽 개발은 영원한 유망주 인것 같습니다. 딥러닝이 21세기 들어 부흥한 것처럼, Web 3D 그래픽스 기술 또한 언젠가는 훨씬 더 많은 주목을 받을 수 있다고 생각합니다. 관련 자료들을 보자면,

- [(강추!)(Website) WebGL2Fundamentals](https://webgl2fundamentals.org/webgl/lessons/ko/): 이번학기 제가 가장 많이 참고자료로 링크를 걸어드린 사이트죠? 이 사이트의 내용이 굉장히 좋아서 이번학기 수업을 위해서 제가 번역을 많이 해 두었습니다. WebGL에 대해 보다 확실히 알고 싶으시면 나머지 내용도 읽어 보시기 바랍니다.

- [(Library) Three.js](https://threejs.org/): Web에서 3D 그래픽 컨텐츠를 만들때 가장 사용하기 좋은 엔진 수준의 라이브러리입니다. 당장 뭔가 내가 3D 그래픽 컨텐츠를 내 사이트에 올리고 싶다면 Three.js를 사용하는 것이 답이라고 봅니다.

- [(Library) X3DOM](https://www.x3dom.org/): Web3D Consortium에서 관리하는 X3D 포맷의 웹 기반 가시화를 위한 프레임워크입니다. 전문적/학문적으로 관심이 있으시다면 살펴 보시면 좋겠습니다.

- [(Library) A-Frame](https://aframe.io/): Web에서의 VR/AR 개발 프레임워크는 아직 사용 사례가 많지 않습니다만 A-Frame은 모질라에서 개발을 시작했고 구글에서도 현재 관리하고 있는 것으로 알고 있고 있습니다. 관심이 있으시다면 미리 봐두면 좋지 않을까 싶습니다.

---

[목록으로](../)
